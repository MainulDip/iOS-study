### Swift-UI intro: 
It's a declarative layout system based on VHZ (Vertical/Y, Horizontal/X, Depth/z) stack. It's inspired form the web design world. Focus on cross-platform apple ecosystem app.
* live preview canvas and drag and drop views on the preview/canvas  area. When dropped, the ui code will be generated by xcode.
* Provide easy code (modular) reusability. cmd + click any stack and select the "extract into sub-view". It will create a struct an call that from the main view. Params can be supplied same way as struct constructor.
* Project Catalyst : convert ios app into mac app (simply checking the mac checkbox on root project config)
* Initially provides 2 structs, 1 for the actual content (ContentView) and other is for the preview/canvas area as Content_Previews
* Device/Canvas Preview frame can be changed in the previews function by using => ContentView().previewDevice(PreviewDevice(rawValue: "iPhone SE")).

### Basic Project Structures
* Directory:
    - ProjectName : Source file for the App
    - ProjectNameTests : Unit Tests
    - ProjectNameUITests : UI Tests
    - Products : 

* Source Directory :
    - <projectname>app.swift : Entry point, @main
    - <anything>view.swift : View File, consumed by @main
    - info.plist : project configuration file
    - Assets.xcassets : Asset files (images, icons, etc) 
    - Preview Content : Generated by xcode for app's preview
### Login-Intro App Docs:
- String to Binding<String> : $string
- @State : @ is attribute in swift
- some : It is used together with a protocol to create an opaque type that represents something that is conformed to a specific protocol. 

```swift
// The following 3 function signatures are identical.

func wash<T: Vehicle>(_ vehicle: T) {
    // Wash the given vehicle
}

func wash<T>(_ vehicle: T) where T: Vehicle {
    // Wash the given vehicle
}

func wash(_ vehicle: some Vehicle)  {
    // Wash the given vehicle
}
```
- CGFloat : NSObject version of a floating point num

### SwiftUI Basics:
- Starting Point: <ProjectName>App.swift is the starting point which is denoted by @main attribute before the struct name. The struct inherit App protocol.
```swift
import SwiftUI

var isUserLoggedIn : Bool = true;

@main // starting point
struct LoginIntroApp: App { // inherit App protocol
    var body: some Scene {
        WindowGroup {
            if isUserLoggedIn {
                MainView()
            } else {
                LoginUIView()
            }
        }
    }
}
```
- Scene : protocol Scene acts as a container for a view hierarchy. It's lifecycle is managed by the system.
- WindowGroup: It's a Scene that represents a group of identically structured windows or view hierarchy. It behaves differently on ios, macos and ipados. Each window created form this maintains independent state. 
- Views : Views are placed inside body. ie: var body: some View { //views are placed here }
    - Layout Views: VStack, HStack, ZStack, Lazy V/H Stacks, Spacer, etc.
    - Control Views: Text, Label, Button, TabView, NavigationView/NavigationLink, Label, etc
    - Paints Views: Angular/Linear/Radial Gradient
    - Other Views: Image, Group, Capsule, Container Relative Shape, Empty View, Menu etc.
- Icons : There are many system icons which can be listed/viewed using "SF Symbols" developer app (need to install it from apples's developer website). And can be inserted into views using : Image(systemName: "NameOfTheIcon")Â 

### Background Color:
Background color works with ZStack (depth stack). So everything needs to be inserted into
```swuft
ZStack {
    Color(.lightGray)
        .edgesIgnoringSafeArea(.all)
}
```
### Custom Font Integration:
- Download the font file (.ttf) and place into project (make a new group/dir named "fonts" and paste the ttf file) 
- check the forn form launchscreen
- add info.plist (on swiftui & xcode14 it's the info of the target) entry on "Fonts provided by application" category, and add the fontName.ttf in the value param. Multiple fonts can be added there, as the category accept array.
- use font as : View(...).font(Font.custom("Font-Name", size: Int))

### Preview Only the content:
```swift
struct ContactBtn_Previews: PreviewProvider {
    static var previews: some View {
        ContactBtn(sysIcon: "link", infoTexts: "Some Text").previewLayout(.sizeThatFits)
    }
}
// also make the preview area "selectable" form the left bottom panel of the preview area
```
### Scene Background Color:
```swift
var body: some View {
    ZStack {
        // some background view
        // some foreground view
        // some view on top of the foreground view
    }
    .frame(maxWidth: .infinity, maxHeight: .infinity)
    .background(Color.green)
}
```

### Working With Images and @State :
```swift
struct ContentView: View {
    /*
     * @State Property Wrapper will make that property mutable
     * and will also any view using that property will be observed
     * and will be changed if the marked property changes
     */
    @State var leftDiceNum = 1
    @State var rightDiceNum = 1
    
    var body: some View {
        ZStack {
            Image("background")
                .resizable() // resizes/stretches an image to fit its space
                .edgesIgnoringSafeArea(.all)
            VStack {
                Spacer()
                Image("diceeLogo")
                Spacer()
                
                HStack {
                    DiceView(n: leftDiceNum)
                    DiceView(n: rightDiceNum)
                }
                .padding(.horizontal)
                
                Spacer()
                Button(action: {
                    // action to dd
                    print("rolling")
                    // @State property wrapper makes these property mutable
                    self.leftDiceNum = Int.random(in: 1...6)
                    self.rightDiceNum = Int.random(in: 1...6)
                    
                }, label: {
                    ZStack {
                        Text("Roll")
                            .font(.system(size: 47))
                            .padding(.horizontal)
                            .foregroundColor(.white)
                    }.background(Color.red)
                })
            }
            .padding()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.green)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

struct DiceView: View {
    let n: Int
    var body: some View {
        Image("dice\(n)")
            .resizable()
            .aspectRatio(1, contentMode: .fit)
    }
}
```

### Lists and Identifiable Protocol:
* Identifiable protocol: It helps to create List items sort by and ID. We need to implement the Identifiable protocol to the SingleList Item struct
### Navigation View With List:

### Advanced State management with Observer Pattern:
This consist of 3 this (at minimum):
- Publisher Class:  A class implementing ObservableObject Protocol
- Publisher Prop: A prop with @Published property wrapper in the ObservableObject Implementing class.
- Subscriber Pops: A prop in Another class declared with @ObservedObject property wrapper.

* When a publisher prop's (from the publisher class) value will be changed, it will update the subscriber prop on another class/struct
```swift
// Publisher class and prop
class NetworkManager: ObservableObject {
    @Published var res = [Post]()
    ...
}

// Subscriber prop
struct ContentView: View {
    @ObservedObject var networkResult = NetworkManager()
    ...
}
```
### UIKit (WebKit) into SwiftUI:
Using WebKit (form UIKit) into SwiftUI, we need to implement the UIViewRepresentable protocol to our custom merging struct
```swift
import WebKit

struct WebView: UIViewRepresentable {
    
//    typealias UIViewType = WKWebView
    let urlStirg: String?
    
    func makeUIView(context: Context) -> WKWebView {
        WKWebView()
    }
    
    func updateUIView(_ uiView: WKWebView, context: Context) {
        if let url_s = urlStirg {
            if let url = URL(string: url_s) {
                let request = URLRequest(url: url)
                uiView.load(request)
            }
        }
    }
}
```

### Navigations:

```swift

@State var goToMain: Bool = false;

var body: some View {
    
    NavigationView {
    
        VStack {

            /**
            * Navigate on state change
            */
                
            NavigationLink(
                destination: MainView(),
                isActive: $goToMain,
                label: {
                    EmptyView()
                }
            )

            /**
            * Click Navigation
            */
                    
            HStack {
                    List {
                        Spacer()
                        Text("Register")
                            .overlay(
                                NavigationLink(
                                    destination: RegisterView()) {
                                    EmptyView();
                                }
                            )
                            .foregroundColor(blue)
                        Spacer()
                    }
            }
                    
        }
    }
    .navigationBarHidden(true)
}
```

### TabView
```swift
import SwiftUI

struct MainView: View {
    var body: some View {
        TabView(selection: Selection ) {
            DashboardView().tabItem { Label(
                title: { Text("Label") },
                icon: { Image(systemName: "house.circle") })
            }
            ProfileView().tabItem { Label(
                title: { Text("Label") },
                icon: { Image(systemName: "person") })
            }
            SettingsView().tabItem {
                Label(
                    title: { Text("Label") },
                    icon: { Image(systemName: "gear") })
            }
        }
    }
}
```

### Swift Language Checklists:
- Delegation: var body: some View {}
- Lambda Syntax
- Generics