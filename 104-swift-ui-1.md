### Swift-UI intros: 
It's a declarative UI Framework based on VHZ (Vertical/Y, Horizontal/X, Depth/z) stack.
* live preview canvas and drag and drop views on the preview/canvas  area. When dropped, the ui code will be generated by xcode.
* Provide easy code (modular) reusability. cmd + click any stack and select the "extract into sub-view". It will create a struct an call that from the main view. Params can be supplied same way as struct constructor.
* Project Catalyst : convert ios app into mac app (simply checking the mac checkbox on root project config)
* Initially provides 2 structs, 1 for the actual content (ContentView) and other is for the preview/canvas area as Content_Previews.......
* Device/Canvas Preview frame can be changed in the previews function by using => ContentView().previewDevice(PreviewDevice(rawValue: "iPhone SE")).......

### Basic Project Structures:
* Directory:
    - ProjectName : Source file for the App
    - ProjectNameTests : Unit Tests
    - ProjectNameUITests : UI Tests
    - Products : 

* Source Directory :
    - <projectname>app.swift : Entry point, @main
    - <anything>view.swift : View File, consumed by @main
    - info.plist : project configuration file
    - Assets.xcassets : Asset files (images, icons, etc) 
    - Preview Content : Generated by xcode for app's preview
### Login-Intro App Docs:
- String to Binding<String> : $string
- `@State` : `@` is attribute in swift (Property wrapper and wrappedValue)
- `some` : It is used together with a protocol to create an opaque type that represents something that is conformed to a specific protocol.

* using `some` keyword, a generic function can minimize code and add syntactic sugar. `func do<T: CustomProtocol>(_ element: T){...}` can be written `func do(_ element: some CustomProtocol){...}`

```swift
// The following 3 function signatures are identical.

func wash<T: Vehicle>(_ vehicle: T) {
    // Wash the given vehicle
}

func wash<T>(_ vehicle: T) where T: Vehicle {
    // Wash the given vehicle
}

func wash(_ vehicle: some Vehicle)  {
    // Wash the given vehicle
}
```
- CGFloat : NSObject version of a floating point num

### SwiftUI Basics:
- Starting Point: <ProjectName>App.swift is the starting point which is denoted by @main attribute before the struct name. The struct inherit App protocol.
```swift
import SwiftUI

var isUserLoggedIn : Bool = true;

@main // starting point
struct LoginIntroApp: App { // inherit App protocol
    var body: some Scene {
        WindowGroup {
            if isUserLoggedIn {
                MainView()
            } else {
                LoginUIView()
            }
        }
    }
}
```
- `Scene` : protocol Scene acts as a container for a view hierarchy. It's lifecycle is managed by the system.
- `WindowGroup`: It's a Scene that represents a group of identically structured windows or view hierarchy. It behaves differently on ios, macos and ipad-os. Each window created form this maintains independent state. 
- `Views` : Views are placed inside body. ie: `var body: some View { //views are placed here }`
    - Layout Views: `VStack`, `HStack`, `ZStack`, `Lazy V/H Stacks`, `Spacer`, etc.
    - Control Views: `Text`, `Label`, `Button`, `TabView`, `NavigationView/NavigationLink`, `Label`, etc
    - Paintings Views: Angular/Linear/Radial Gradient
    - Other Views: `Image`, `Group`, `Capsule`, `Container` Relative Shape, Empty View, Menu etc.
- `Icons` : There are many system icons which can be listed/viewed using "SF Symbols" developer app (need to be installed), And can be inserted into views using : Image(systemName: "NameOfTheIcon").......

### Background Color:
Background color works with ZStack (depth stack). So everything needs to be inserted into ZStack

```swift
ZStack {
    Color(.lightGray)
        .edgesIgnoringSafeArea(.all)
}
```
### Custom Font Integration:
- Download the font file (.ttf) and place into project (make a new group/dir named "fonts" and paste the ttf file) 
- check the font from launchscreen
- add info.plist (on swiftui & xcode14 it's the info of the target) entry on "Fonts provided by application" category, and add the fontName.ttf in the value param. Multiple fonts can be added there, as the category accept array.
- use font as : View(...).font(Font.custom("Font-Name", size: Int))

### Preview Only the content:
```swift
struct ContactBtn_Previews: PreviewProvider {
    static var previews: some View {
        ContactBtn(sysIcon: "link", infoTexts: "Some Text").previewLayout(.sizeThatFits)
    }
}
// also make the preview area "selectable" form the left bottom panel of the preview area
```
### Scene Background Color:
```swift
var body: some View {
    ZStack {
        // some background view
        // some foreground view
        // some view on top of the foreground view
    }
    .frame(maxWidth: .infinity, maxHeight: .infinity)
    .background(Color.green)
}
```

### Working With Images and @State :
```swift
struct ContentView: View {
    /*
     * @State Property Wrapper will make that property mutable
     * and will also any view using that property will be observed
     * and will be changed if the marked property changes
     */
    @State var leftDiceNum = 1
    @State var rightDiceNum = 1
    
    var body: some View {
        ZStack {
            Image("background")
                .resizable() // resizes/stretches an image to fit its space
                .edgesIgnoringSafeArea(.all)
            VStack {
                Spacer()
                Image("diceeLogo")
                Spacer()
                
                HStack {
                    DiceView(n: leftDiceNum)
                    DiceView(n: rightDiceNum)
                }
                .padding(.horizontal)
                
                Spacer()
                Button(action: {
                    // action to dd
                    print("rolling")
                    // @State property wrapper makes these property mutable
                    self.leftDiceNum = Int.random(in: 1...6)
                    self.rightDiceNum = Int.random(in: 1...6)
                    
                }, label: {
                    ZStack {
                        Text("Roll")
                            .font(.system(size: 47))
                            .padding(.horizontal)
                            .foregroundColor(.white)
                    }.background(Color.red)
                })
            }
            .padding()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.green)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

struct DiceView: View {
    let n: Int
    var body: some View {
        Image("dice\(n)")
            .resizable()
            .aspectRatio(1, contentMode: .fit)
    }
}
```

### Lists and Identifiable Protocol:
* Identifiable protocol: It helps to create List items sort by and ID. We need to implement the Identifiable protocol to the SingleList Item struct
### Navigation View With List:

### Advanced State management with Observer Pattern:
This consist of 3 this (at minimum):
- Publisher Class:  A class implementing ObservableObject Protocol
- Publisher Prop: A prop with @Published property wrapper in the ObservableObject Implementing class.
- Subscriber Pops: A prop in Another class declared with @ObservedObject property wrapper.

* When a publisher prop's (from the publisher class) value will be changed, it will update the subscriber prop on another class/struct
```swift
// Publisher class and prop
class NetworkManager: ObservableObject {
    @Published var res = [Post]()
    ...
}

// Subscriber prop
struct ContentView: View {
    @ObservedObject var networkResult = NetworkManager()
    ...
}
```
### UIKit (WebKit) into SwiftUI:
Using WebKit (form UIKit) into SwiftUI, we need to implement the UIViewRepresentable protocol to our custom merging structs
```swift
import WebKit

struct WebView: UIViewRepresentable {
    
//    typealias UIViewType = WKWebView
    let urlStirg: String?
    
    func makeUIView(context: Context) -> WKWebView {
        WKWebView()
    }
    
    func updateUIView(_ uiView: WKWebView, context: Context) {
        if let url_s = urlStirg {
            if let url = URL(string: url_s) {
                let request = URLRequest(url: url)
                uiView.load(request)
            }
        }
    }
}
```

### Navigation:

```swift

@State var goToMain: Bool = false;

var body: some View {
    
    NavigationView {
    
        VStack {

            /**
            * Navigate on state change
            */
                
            NavigationLink(
                destination: MainView(),
                isActive: $goToMain,
                label: {
                    EmptyView()
                }
            )

            /**
            * Click Navigation
            */
                    
            HStack {
                    List {
                        Spacer()
                        Text("Register")
                            .overlay(
                                NavigationLink(
                                    destination: RegisterView()) {
                                    EmptyView();
                                }
                            )
                            .foregroundColor(blue)
                        Spacer()
                    }
            }
                    
        }
    }
    .navigationBarHidden(true)
}
```

### TabView
```swift
import SwiftUI

struct MainView: View {
    var body: some View {
        TabView(selection: Selection ) {
            DashboardView().tabItem { Label(
                title: { Text("Label") },
                icon: { Image(systemName: "house.circle") })
            }
            ProfileView().tabItem { Label(
                title: { Text("Label") },
                icon: { Image(systemName: "person") })
            }
            SettingsView().tabItem {
                Label(
                    title: { Text("Label") },
                    icon: { Image(systemName: "gear") })
            }
        }
    }
}
```

### `@ViewBuilder` and `@resultBuilder`:
The `@ViewBuilder` attribute is one of the few result builders `@resultBuilder` already available in SwiftUI. Used to constructs one or more view from closures.

```swift
struct VHStack<Content: View>: View {
    @Environment(\.horizontalSizeClass) var horizontalSizeClass

    let content: Content

    init(@ViewBuilder _ content: () -> Content) {
        self.content = content()
    }

    var body: some View {
        if horizontalSizeClass == .compact {
            VStack {
                content
            }
        } else {
            HStack {
                content
            }
        }
    }
}

struct ContentView: View {
    var body: some View {
        VHStack {
            Text("Hello, World!")
            Text("Result Builders are great!")
        }
    }
}

// we can get rid of custom init, as Structs comes with a default one
struct VHStack<Content: View>: View {
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    @ViewBuilder var content: () -> Content

    var body: some View {
        if horizontalSizeClass == .compact {
            VStack {
                content()
            }
        } else {
            HStack {
                content()
            }
        }
    }
}

// Creating methods with `@ViewBuilder`
extension Slider {
    @ViewBuilder
    func minimumTrackColor(_ color: Color) -> some View {
        if #available(macOS 11.0, *) {
            accentColor(color)
        } else {
            self
        }
    }
}
```


Docs: https://www.avanderlee.com/swiftui/viewbuilder/

* `@resultBuilder` : Result builders are used to build up a result using ‘build blocks’ lined up after each other. It's kind of creating a `DSL` for building a result minimizing return statement.......

* requires to have `buildBlock()` function

```swift
@resultBuilder
struct SimpleStringBuilder {
    static func buildBlock(_ parts: String...) -> String {
        parts.joined(separator: "\n")
    }
}

let joined = SimpleStringBuilder.buildBlock(
    "Why settle for a Duke",
    "when you can have",
    "a Prince?"
)

print(joined)

// using with function 
@SimpleStringBuilder func makeSentence3() -> String {
    "Why settle for a Duke"
    "when you can have"
    "a Prince?"
}

print(makeSentence3())
```

Docs: https://www.hackingwithswift.com/swift/5.4/result-builders.......